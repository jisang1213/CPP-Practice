// Overview of C++20’s three-way comparison (“spaceship”) operator <=>
// <=> generates all six relational operators (==, !=, <, <=, >, >=)
// It help reduce boilerplate code

#include <compare>
#include <iostream>
#include <string>
#include <limits>

struct Person{
    std::string name;
    int age;    
    Person(std::string name, int age) : name(name), age(age) {}

    // Integral types yield strong ordering, floating point types yield partial ordering
    auto operator<=>(const Person&) const = default; // compares all members in declaration order

    /*
    1. If any member’s compare yields partial_ordering, the whole <=> returns partial_ordering.
    2. Else if any yields weak_ordering, you get weak_ordering.
    3. Otherwise you get strong_ordering.

                      Equivalent values are... , incomparable values are...:
    std::strong_ordering	indistinguishable, not allowed
    std::weak_ordering	distinguishable, 	not allowed
    std::partial_ordering 	distinguishable, 	allowed

    // You can also provide a custom implementation of the <=> operator as such:
    auto operator<=>(const Person& other) const{
        return name <=> other.name; // return type is deduced to std::strong_ordering
    }

    // You can enforce the return type to be a strong_ordering if you desire:
    std::strong_ordering operator<=>(const Person& other) const{
        return name <=> other.name;
    }

    // In this case you need to provide operator== because the compiler will not autogenerate it
    // If you omit it, you can still do if ((s1 <=> s2) == 0) but not if(s1 == s2)
    bool operator==(const Person&) const =  default; 

    generated by the compiler:
    friend constexpr bool operator==(const C& lhs, const C& rhs) noexcept {
        return (lhs <=> rhs) == 0;
    }
    friend constexpr bool operator!=(const C& lhs, const C& rhs) noexcept {
        return !(lhs == rhs);
    }
    friend constexpr bool operator< (const C& lhs, const C& rhs) noexcept {
        return (lhs <=> rhs) <  0;
    }
    friend constexpr bool operator<=(const C& lhs, const C& rhs) noexcept {
        return (lhs <=> rhs) <= 0;
    }
    friend constexpr bool operator> (const C& lhs, const C& rhs) noexcept {
        return (lhs <=> rhs) >  0;
    }
    friend constexpr bool operator>=(const C& lhs, const C& rhs) noexcept {
        return (lhs <=> rhs) >= 0;
    }
    */
}; 
struct U {
    int i;
    auto operator<=>(const U&) const = default;
};

struct V {
    int i;
    double j;
    auto operator<=>(const V&) const = default;
};

using namespace std;

int main(){
    int   x, y;
    auto c1 = (x <=> y);           // std::strong_ordering
    static_assert(std::is_same_v<decltype(c1), std::strong_ordering>);

    double p, q;
    auto c2 = (p <=> q);           // std::partial_ordering
    static_assert(std::is_same_v<decltype(c2), std::partial_ordering>);

    auto c3 = (U{1} <=> U{2});     // std::strong_ordering
    static_assert(std::is_same_v<decltype(c3), std::strong_ordering>);

    auto c4 = (V{1,0.0} <=> V{1, std::numeric_limits<double>::quiet_NaN()}); // std::partial_ordering
    static_assert(std::is_same_v<decltype(c4), std::partial_ordering>);

    // std::weak_ordering is never produced by built-in <=> (only for custom <=>)
    // std::weak_ordering w = /*…*/;
    // std::partial_ordering p = w;  // Implicit conversion from weak_ordering to partial_ordering always allowed
    
    // Weak ordering has three outcome: <, equivalent, >.
    // Partial ordering has four outcomes: <, equivalent, >, unordered (e.g. comparison with NaN)
    // if ((cmp != cmp))  // only true when unordered

    /*
    In summary, these are all the possible outcomes
    a == b ? std::strong_ordering::equal :
    a < b  ? std::strong_ordering::less :
            std::strong_ordering::greater

    a == b ? std::weak_ordering::equivalent :
    a < b  ? std::weak_ordering::less :
            std::weak_ordering::greater

    a == b ? std::partial_ordering::equivalent :
    a < b  ? std::partial_ordering::less :
    b < a  ? std::partial_ordering::greater : 
            std::partial_ordering::unordered
    */

    Person a{"Bob", 25};
    Person b{"John", 23};

    using Cat = decltype(a <=> b);  // Cat is the actual return type
    static_assert(std::is_same_v<Cat, std::strong_ordering>);

    // a <=> b returns a comparison‐category object (strong_ordering, weak_ordering, or partial_ordering), not bool
    // The compiler will pick the strongest category that all sub-objects support. If you only have ints and strings, that’s strong_ordering.

    if((a<=>b) < 0){ // This is functionally equivalent to calling (a<=>b) == std::strong_ordering::less
       cout << a.name << " is less than " << b.name << endl;
    }
    else{
       cout << b.name << " is less than " << a.name << endl;
    }

    // We can compare the result of a<=>b to 0 with any of the 6 operators (see below for implementation)
    auto cmp = (a<=>b);
    if (cmp <  0)  /* true if a <  b */  
    if (cmp <= 0)  /* true if a <= b */  
    if (cmp == 0)  /* true if a == b */  
    if (cmp != 0)  /* true if a != b */  
    if (cmp >= 0)  /* true if a >= b */  
    if (cmp >  0)  /* true if a >  b */  

    // Or use std functions
    bool less   = std::is_lt   (cmp); // true if cmp <  0
    bool le      = std::is_lteq (cmp); // true if cmp <= 0
    bool equal  = std::is_eq   (cmp); // true if cmp == 0
    bool ne      = std::is_neq  (cmp); // true if cmp != 0
    bool gt      = std::is_gt   (cmp); // true if cmp >  0
    bool ge      = std::is_gteq (cmp); // true if cmp >= 0

    // You could also just direct do the following since the operators are defined as friend functions:
    if(a < b){
       cout << a.name << " is less than " << b.name << endl;
    }
    else{
       cout << b.name << " is less than " << a.name << endl;
    }
}


// Simplified implementation of comparison to 0:
/*
class strong_ordering {
  int __v;  // internal tag: -1, 0, +1

  explicit constexpr strong_ordering(int __val) noexcept
    : __v(__val) {}

public:
  // the three named constant values
  inline static constexpr strong_ordering less    = strong_ordering(-1);
  inline static constexpr strong_ordering equal   = strong_ordering( 0);
  inline static constexpr strong_ordering greater = strong_ordering(+1);

  // three-way compare itself (defaulted)
  friend constexpr bool operator==(strong_ordering a,
                                    strong_ordering b) noexcept = default;

  // — relational comparisons against the literal 0 (undefined if not 0)

  friend constexpr bool operator< (strong_ordering cmp, int) noexcept {
    return cmp.__v <  0;
  }
  friend constexpr bool operator<=(strong_ordering cmp, int) noexcept {
    return cmp.__v <= 0;
  }
  friend constexpr bool operator==(strong_ordering cmp, int) noexcept {
    return cmp.__v == 0;
  }
  friend constexpr bool operator!=(strong_ordering cmp, int) noexcept {
    return cmp.__v != 0;
  }
  friend constexpr bool operator> (strong_ordering cmp, int) noexcept {
    return cmp.__v >  0;
  }
  friend constexpr bool operator>=(strong_ordering cmp, int) noexcept {
    return cmp.__v >= 0;
  }
};
*/ 